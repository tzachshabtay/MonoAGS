<#@ assembly name="System.Runtime" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ include file="FlatInterfaceTemplate.tt" #><#+
    class EntityCreator: TextTransformation
    {
        public string NamespaceName { get; set; }
        public string ClassName { get; set; }
        public List<Type> Components { get; set; }
        public string AdditionalInterfaces { get; set; }
        public Func<FlatEntityTemplate> CustomTemplate { get; set; }
        public Type ComponentType { get; set; } //should be set to IComponent from outside, just want to avoid the assembly reference in this template

        protected virtual bool ProcessInterface(Type interfaceType)
        {
			return ComponentType.GetTypeInfo().IsAssignableFrom(interfaceType.GetTypeInfo()) && interfaceType != ComponentType;
        }

        protected virtual void WriteAdditionalUsings()
        {
        }

        protected virtual bool WriteImplements(Type interfaceType)
        {
            return true;
        }

        protected virtual void WriteAdditionalConstructorParams()
        {
        }

        protected virtual void WriteAdditionalConstructorParamsCall()
        {
        }

        protected virtual bool WriteInitComponent(Type interfaceType)
        {
            return WriteComponentVariable(interfaceType);
        }

        protected virtual bool WriteComponentVariable(Type interfaceType)
        {
            if (interfaceType.Name.Contains("IInTree")) return false;
            return true;
        }

        protected virtual void WriteAdditionalInits()
        {
        }

        public override string TransformText()
        {
            if (NamespaceName == null || ClassName == null || Components == null)
                return GenerationEnvironment.ToString();

            FlatEntityTemplate helper = new FlatEntityTemplate();

            HashSet<string> interfacesToProcess = new HashSet<string>();
            List<Type> allComponents = Components.SelectMany(c => c.GetInterfaces()).ToList();
            allComponents.AddRange(Components);
            Components = allComponents.Where(c => ComponentType.GetTypeInfo().IsAssignableFrom(c.GetTypeInfo()) && c != ComponentType
                && ProcessInterface(c)).ToList();    
        
            string implements = string.Format("{0}{1}", AdditionalInterfaces ?? "", 
                string.Join(", ", Components.Where(c => WriteImplements(c)).Select(c => helper.GetTypeName(c))));
            if (Components.Count > 0) implements = ", " + implements;
                #>
//This class was automatically generated by a T4 template.
//Making manual changes in this class might be overridden if the template will be processed again.
//If you want to add functionality you might be able to do this via another partial class definition for this class.

using System;
using AGS.API;
using AGS.Engine;
<#+ WriteAdditionalUsings(); #>


namespace <#= NamespaceName #>
{
    public partial class <#= ClassName #> : AGSEntity<#= implements #>
    {<#+
        foreach (var component in Components)
        {
            if (!WriteComponentVariable(component)) continue;
        #>

        private <#= helper.GetTypeName(component) #> <#= getVarName(component) #>;<#+
        }#>


        public <#= ClassName #>(string id, Resolver resolver<#+ WriteAdditionalConstructorParams(); #>) : base(id, resolver)
        {<#+

        foreach (var component in Components)
        {
            if (!
            WriteInitComponent(component)) continue;#>

            <#= getVarName(component) #> = AddComponent<<#= helper.GetTypeName(component) #>>();
            Bind<<#= helper.GetTypeName(component) #>>(c => <#= getVarName(component) #> = c, _ => {});<#+
            }
        WriteAdditionalInits();
        #>

			beforeInitComponents(resolver<#+ WriteAdditionalConstructorParamsCall(); #>);
            InitComponents();
            afterInitComponents(resolver<#+ WriteAdditionalConstructorParamsCall(); #>);
            }

        public string Name { get { return ID; } }
        public bool AllowMultiple { get { return false; } }
        public IEntity Entity { get => this; }
        public Type RegistrationType { get => typeof(IEntity); }
        public void Init(IEntity entity, Type registrationType) {}

        public override string ToString()
        {
            return string.Format("{0} ({1})", ID ?? "", GetType().Name);
        }

        partial void beforeInitComponents(Resolver resolver<#+ WriteAdditionalConstructorParams(); #>);
		partial void afterInitComponents(Resolver resolver<#+ WriteAdditionalConstructorParams(); #>);
<#+           
            foreach (var component in Components)
            {
                List<Type> allInterfaces = new List<Type> { component };
                 allInterfaces.AddRange(component.GetInterfaces());
                 foreach (var compInterface in allInterfaces)
                 {
                     bool shouldProcess = interfacesToProcess.Add(compInterface.Name);
                     if (!shouldProcess) continue;
                     FlatEntityTemplate template = CustomTemplate == null ? new FlatEntityTemplate() : CustomTemplate();
                    template.VarName = getVarName(component);
                    template.InterfaceType = compInterface;
                    string output = template.TransformText();
                    if (output != null)
                    {#><#+
                        Write(output);
                    }
                }
            }#>
    }
}
<#+
            return GenerationEnvironment.ToString();
        }

        private string getVarName(Type component)
        {
            if (component.Name.Contains("IInTree")) return "_inObjectTree";
            string typeName = component.Name;
            string varName = "";
            if (typeName.Length <= 1) varName = typeName;
            else 
            {
                int wordStart = typeName[0] == 'I' ? 1 : 0;
                varName = string.Format("{0}{1}", Char.ToLower(typeName[wordStart]), typeName.Substring(wordStart + 1));
            } 
            if (component.GetTypeInfo().IsGenericType)
            {
                varName = varName.Substring(0, varName.Length - 2);
            }
            return string.Format("_{0}", varName);
        }
    }

    class FlatEntityTemplate : MixinTemplate
    {
        protected override bool FlattenInterface(Type interfaceType)
        {
            if (interfaceType == typeof(IDisposable) || interfaceType.Name.Contains("IEnumerable")
                || interfaceType.Name.Contains("IComponent") || interfaceType.Name == "IEntity") return false; 
            return base.FlattenInterface(interfaceType);
        }
    }
#>
